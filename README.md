# 컴파일
<br>

## 1. 전처리(Precompile)

컴파일의 전체 과정은 네 단계로 나누어볼 수 있습니다. 그 중 첫 번째 단계는 전처리인데, 전처리기에 의해 수행됩니다. # 으로 시작되는 C 소스 코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려줍니다.<br>

예를 들어, #include는 전처리기에게 다른 파일의 내용을 포함시키라고 알려줍니다. 프로그램의 소스 코드에 #include 와 같은 줄을 포함하면, 전처리기는 새로운 파일을 생성하는데 이 파일은 여전히 C 소스 코드 형태이며 stdio.h 파일의 내용이 #include 부분에 포함됩니다.<br>
<br>

## 2. 컴파일(Precompile)

전처리기가 전처리한 소스 코드를 생성하고 나면 그 다음 단계는 컴파일입니다. 컴파일러라고 불리는 프로그램은 C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일합니다.<br>

어셈블리는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있습니다.
<br>
C 코드를 어셈블리 코드로 변환시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만들어 줍니다.<br>
컴파일이라는 용어는 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 하지만, 구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 합니다.<br>
<br>

## 3. 어셈블(Assemble)

소스 코드가 어셈블리 코드로 변환되면, 다음 단계인 어셈블 단계로 어셈블리 코드를 오브젝트 코드로 변환시키는 것입니다.<br>

컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 연속된 0과 1들로 바꿔주는 작업이죠.<br>
이 변환작업은 어셈블러라는 프로그램이 수행합니다. 소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 여기서 끝이 납니다. 그러나 그렇지 않은 경우에는 링크라 불리는 단계가 추가됩니다.<br>
<br>

## 4. 링크(Link)

만약 프로그램이 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크라는 컴파일의 마지막 단계가 필요합니다. <br>

링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐줍니다.<br>
<br>
<br>

# 메모리

2개의 16진수는 1byte의 2진수로 변환되기 때문에 정보를 표현하기 매우 유용합니다.<br>
그 예로 메모리 주소는 16진수로 저장됩니다.<br>
C에는 아래와 같은 여러 자료형이 있고, 각각의 자료형은 서로 다른 크기의 메모리를 차지합니다.<br>

bool: 불리언, 1바이트<br>
char: 문자, 1바이트<br>
int: 정수, 4바이트<br>
float: 실수, 4바이트<br>
long: (더 큰) 정수, 8바이트<br>
double: (더 큰) 실수, 8바이트<br>
string: 문자열, ?바이트<br>
<br>
<br>

# 알고리즘
<br>

## 선형 검색

배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사합니다.<br>
선형 검색은 자료가 정렬되어 있지 않거나 그 어떤 정보도 없어 하나씩 찾아야 하는 경우에 유용합니다.<br>
<br>

## 이진 탐색

만약 배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은(작은 값이 저장되어 있는) 인덱스 또는 큰 (큰 값이 저장되어 있는) 인덱스로 이동을 반복하면 됩니다.<br>
<br>

## 버블 정렬

두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법을 말합니다.<br>

이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있습니다.<br>

정렬이 되어 있는지 여부에 관계 없이 루프를 돌며 비교를 해야 하므로 위와 같은 코드로 작성한 버블 정렬의 실행 시간의 하한도 여전히 Ω(n^2)이 됩니다.<br>
<br>

## 선택 정렬

보통 배열이 정렬되어 있으면 정렬되지 않은 배열보다 더 쉽게 탐색할 수 있습니다.<br>

정렬을 위한 알고리즘 중 선택정렬을 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬입니다.<br>

선택 정렬은 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가합니다.<br>

다음과 같은 정렬되지 않은 숫자들을 오름차순 정렬해보도록 하겠습니다.<br>

```
    6 3 8 5 2 7 4 1
```

먼저 아래 숫자들 중에서 가장 작은 값을 찾습니다.<br>

```
    6 3 8 5 2 7 4 1
```

가장 작은 값인 1은 가장 앞에 있어야 하므로 현재 리스트의 첫 번째 값인 6과 교환합니다.<br>

```
    1 3 8 5 2 7 4 6
```

그리고 정렬되어 있는 1은 제외하고, 두 번째 숫자부터 시작해서 또 가장 작은 값을 찾습니다.<br>

```
    1 3 8 5 2 7 4 6
```

가장 작은 값인 2는 정렬되지 않는 숫자들 중에서 가장 앞에 있어야 하므로 3과 교환합니다.<br>

```
    1 2 8 5 3 7 4 6
```

이 과정을 더 이상 교환이 일어나지 않을때까지 반복하면, 아래와 같이 오름차순 정렬이 완료됩니다.<br>

```
1 2 3 4 5 6 7 8
```

이러한 정렬 방법을 ‘선택 정렬’ 이라고 합니다.<br>
<br>

## 병합 정렬

원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식입니다.<br>

```
 다음 숫자들을 오름차순으로 정렬해 보겠습니다.
        7 4 5 2 6 3 8 1



7 | 4 | 5 | 2 | 6 | 3 | 8 | 1 → 가장 작은 부분 (숫자 1개)으로 나눠진 결과입니다.

4   7 | 2   5 | 3   6 | 1   8 → 숫자 1개씩을 정렬하여 병합한 결과입니다.

2   4   5   7 | 1   3   6   8 → 숫자 2개씩을 정렬하여 병합한 결과입니다.

1   2   3   4   5   6   7   8 → 마지막으로 숫자 4개씩을 정렬하여 병합한 결과입니다.
```

병합 정렬 실행 시간의 상한은 O(n log n) 입니다.<br>

숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸리기 때문입니다.<br>
실행 시간의 하한도 역시 Ω(n log n) 입니다. 숫자들이 이미 정렬되었는지 여부에 관계 없이 나누고 병합하는 과정이 필요하기 때문입니다.<br>

병합 정렬은 최선의 경우에도, 최악의 경우에도 O(nlog₂n)의 시간이 소요되기 때문에 데이터 분포에 영향을 덜 받습니다. 항상 동일한 시간이 소요되므로 어떤 경우에도 좋은 성능을 보장받을 수 있습니다.<br>
하지만 병합 정렬은 in place 알고리즘이 아니기 때문에 별도의 메모리 공간이 필요합니다. 만약에 정렬할 데이터의 양이 많은 경우에는 그만큼 이동 횟수가 많아지므로 시간적인 낭비도 많아지게 됩니다.<br>
<br>

## 알고리즘 표기법

Big O가 알고리즘 실행 시간의 상한을 나타낸 것이라면, 반대로 Big Ω는 알고리즘 실행 시간의 하한을 나타내는 것입니다.<br>
예를 들어 선형 검색에서는 n개의 항목이 있을때 최대 n번의 검색을 해야 하므로 상한이 O(n)이 되지만 운이 좋다면 한 번만에 검색을 끝낼수도 있으므로 하한은 Ω(1)이 됩니다.<br>
<br>

### Big O
<br>
O(n^2) - 선택 정렬, 버블 정렬, 삽입 정렬<br>
O(n log n) - 병합 정렬, 힙 정렬<br>
O(n) - 선형 검색<br>
O(log n) - 이진 검색<br>
O(1)<br>
<br>

### Big Ω

Ω(n^2)  - 선택 정렬<br>
Ω(n log n) - 병합 정렬 , 힙 정렬<br>
Ω(n) -  버블 정렬, 삽입 정렬<br>
Ω(log n)<br>
Ω(1) - 선형 검색, 이진 검색<br>

<img width="477" alt="그림1" src="https://user-images.githubusercontent.com/5775698/175834815-e70a443e-138f-432e-9a00-9906e907513c.png">
<br>
<br>

# 스택 & 힙 (Stack & Heap)

![image](https://user-images.githubusercontent.com/5775698/175833623-bc642c8b-1099-4527-978c-4b257a9ad27d.png)

위 그림에서와 같이 메모리 안에는 데이터 저장되는 구역이 나뉘어져 있습니다.<br>

- 머신 코드 영역에는 우리 프로그램이 실행될 때 그 프로그램이 컴파일된 바이너리가 저장됩니다.<br>
  프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다.<br>
  CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.<br>

- 글로벌 영역에는 프로그램 안에서 저장된 전역 변수가 저장됩니다. ('데이터 영역'이라고 합니다.)<br>
  프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.<br>
  데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.<br>

- 힙 영역에는 malloc으로 할당된 메모리의 데이터가 저장됩니다.<br>
  사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’ 메모리 영역입니다.<br>
  힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.<br>
  힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.<br>

- 스택에는 프로그램 내의 함수와 관련된 것들이 저장됩니다.<br>
  함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.<br>
  스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.<br>
  이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.<br>

  푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.<br>
  후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.<br>
  스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.<br>
<br>
<br>

# 연결리스트 (Linked list)

연결리스트는 순서가 있는 데이터를 늘어놓은 형태의 자료구조를 의미합니다.<br>
연결리스트는 각각의 데이터가 그 다음의 데이터를 가리키는 방식으로 순서를 구현합니다.<br>

연결리스트의 각 원소는 노드 (Node) 라고 하는데 각 노드는 데이터와 그 다음 노드를 가리키는 포인터(Pointer)를 가지고 있습니다.<br>
연결리스트의 맨 앞과 맨 끝 노드를 각각 머리 (Head), 꼬리 (Tail) 노드라고 합니다.<br>
각 노드의 앞쪽 노드를 전임 노드 (Predecessor Node), 뒤쪽 노드를 후임 노드 (Successor Node) 라고 합니다.<br>

배열과 비교해서 연결 리스트는 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다는 장점이 있습니다.<br>
하지만 이런 유동적인 구조는 그 대가가 따릅니다. 구조가 정적인 배열과 달리 연결 리스트에서는 임의 접근이 불가능합니다.<br>

연결 리스트에 값을 추가하거나 검색하는 경우를 생각해 봅시다.<br>
이를 위해서는 해당하는 위치까지 연결 리스트의 각 node들을 따라 이동해야 합니다.<br>
따라서 연결 리스트의 크기가 n 일때 그 실행 시간은 O(n)이 됩니다.<br>
배열의 경우 임의 접근이 가능하기 때문에 (정렬 되어 있는 경우) 이진 검색을 이용하면 O(log n)의 실행 시간이 소요 되는 것에 비해서 다소 불리합니다.<br>

이처럼 여러 데이터 구조는 각각 장단점이 존재합니다.<br>
프로그래밍을 할 때 목적에 부합하는 가장 효율적인 데이터 구조를 고민해서 사용하는 것이 중요합니다.<br>
<br>
<br>

# 트리 (Tree)

트리는 연결리스트를 기반으로 한 새로운 데이터 구조입니다.<br>
연결리스트에서의 각 노드 (연결 리스트 내의 한 요소를 지칭)들의 연결이 1차원적으로 구성되어 있다면, 트리에서의 노드들의 연결은 2차원적으로 구성되어 있다고 볼 수 있습니다.<br>
각 노드는 일정한 층에 속하고, 다음 층의 노드들을 가리키는 포인터를 가지게 됩니다.<br>

아래 그림은 트리의 한 예입니다. 나무가 거꾸로 뒤집혀 있는 형태를 생각하면 됩니다.<br>
가장 높은 층에서 트리가 시작되는 노드를 ‘루트’라고 합니다. 루트 노드는 다음 층의 노드들을 가리키고 있고, 이를 ‘자식 노드’라고 합니다.<br>

![image](https://user-images.githubusercontent.com/5775698/175834999-290ebf71-5602-476c-ad77-cf339cc4931f.png)

위 그림에 묘사된 트리는 구체적으로 ‘이진 검색 트리’ 입니다. 각 노드가 구성되어 있는 구조를 살펴보면 일정한 규칙을 알 수 있습니다.<br>
먼저 하나의 노드는 두 개의 자식 노드를 가집니다. 또 왼쪽 자식 노드는 자신의 값 보다 작고, 오른쪽 자식 노드는 자신의 값보다 큽니다.<br>
따라서 이런 트리 구조는 이진 검색을 수행하는데 유리합니다.<br>
<br>
<br>

# 해시테이블 (Hash Table)

해시 테이블은 ‘연결 리스트의 배열’입니다. 여러 값들을 몇 개의 바구니에 나눠 담는 상황을 생각해 봅시다.<br>
각 값들은 ‘해시 함수’라는 맞춤형 함수를 통해서 어떤 바구니에 담기는 지가 결정되는데 각 바구니에 담기는 값들은 그 바구니에서 새롭게 정의되는 연결 리스트로 이어집니다.<br>
이와 같이 연결 리스트가 담긴 바구니가 여러개 있는 것이 ‘연결 리스트의 배열’, 즉 ‘해시 테이블’이 됩니다.<br>

쉬운 예로 아래 그림과 같이 사람의 이름이 해시 테이블에 저장되며, 해시 함수는 ‘이름의 가장 첫 글자’인 경우를 생각해 보겠습니다.<br>

그 경우 알파벳 개수에 해당하는 총 26개의 포인터들이 있을 수 있으며, 각 포인터는 그 알파벳을 시작으로 하는 이름들을 저장하는 연결 리스트를 가리키게 됩니다.<br>

![image](https://user-images.githubusercontent.com/5775698/175835057-7a22cf6f-d003-408a-a057-fe09719b13b3.png)

만약 해시 함수가 이상적이라면, 각 바구니에는 단 하나의 값들만 담기게 될 것입니다. 따라서 검색 시간은 O(1)이 됩니다.<br>
하지만 그렇지 않은 경우, 최악의 상황에는 단 하나의 바구니에 모든 값들이 담겨서 O(n)이 될 수도 있습니다.<br>
일반적으로는 최대한 많은 바구니를 만드는 해시 함수를 사용하기 때문에 거의 O(1)에 가깝다고 볼 수 있습니다.<br>
<br>
<br>

# 트라이 (Trie)

‘트라이’는 기본적으로 ‘트리’ 형태의 자료 구조입니다. 특이한 점은 각 노드가 ‘배열’로 이루어져있다는 것입니다.<br>
예를 들어 영어 알파벳으로 이루어진 문자열 값을 저장한다고 한다면 이 노드는 a부터 z까지의 값을 가지는 배열이 됩니다.<br>
그리고 배열의 각 요소, 즉 알파벳은 다음 층의 노드(a-z 배열)를 가리킵니다.<br>

아래 그림과 같이 Hermione, Harry, Hagrid 세 문자열을 트라이에 저장해보겠습니다.<br>
루트 노드를 시작으로 각 화살표가 가리키는 알파벳을 따라가면서 노드를 이어주면 됩니다.<br>

![image](https://user-images.githubusercontent.com/5775698/175835119-319b399b-4114-482a-a37a-2988390a77c9.png)

위와 같은 트라이에서 값을 검색하는데 걸리는 시간은  ‘문자열의 길이’에 의해 한정됩니다. 단순히 문자열의 각 문자를 보며 트리를 탐색해나가기만 하면 되니까요.<br>
일반적인 영어 이름의 길이를 n이라고 했을 때, 검색 시간은 O(n)이 되지만, 대부분의 이름은 그리 크지 않은 상수값(예, 20자 이내)이기 때문에 O(1)이나 마찬가지라고 볼 수 있습니다.<br>
<br>
<br>

# 스택 & 큐 (Stack & Queue) , 딕셔너리 (Dictionary)
<br>

## 스택

스택은 역시 메모리 구조에서 살펴봤듯이 값이 위로 쌓이는 구조입니다.<br>

따라서 값을 넣고 뺄 때 ‘후입 선출’ 또는 ‘LIFO’라는 방식을 따르게 됩니다. 가장 나중에 들어온 값이 가장 먼저 나가는 것이죠.<br>

뷔페에서 접시를 쌓아 뒀을 때 사람들이 가장 위에 있는(즉, 가장 나중에 쌓인) 접시를 가장 먼저 들고 가는 것과 동일합니다.<br>

배열이나 연결 리스트를 통해 구현 가능합니다.<br>
<br>

## 큐

큐는 메모리 구조에서 살펴봤듯이 값이 아래로 쌓이는 구조입니다.<br>

값을 넣고 뺄 때 ‘선입 선출’ 또는 ‘FIFO’라는 방식을 따르게 됩니다. 가장 먼저 들어온 값이 가장 먼저 나가는 것이죠.은행에서 줄을 설 때 가장 먼저 줄을 선 사람이 가장 먼저 업무를 처리하게 되는 것과 동일합니다.<br>

역시 배열이나 연결 리스트를 통해 구현 가능합니다.<br>
<br>

## 딕셔너리

딕셔너리는 ‘키’와 ‘값’이라는 요소로 이루어져 있습니다.<br>

‘키’에 해당하는 ‘값’을 저장하고 읽어오는 것이죠. 마치 대학교에서 ‘학번’에 따라서 ‘학생’이 결정되는 것과 동일합니다.<br>

일반적인 의미에서 ‘해시 테이블’과 동일한 개념이라고도 볼 수 있는데 역시 ‘키’를 어떻게 정의할 것인지가 중요합니다.<br>